<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Users</a> &gt; <a href="index.source.html" class="el_package">UserApp.service</a> &gt; <span class="el_source">UserService.java</span></div><h1>UserService.java</h1><pre class="source lang-java linenums">package UserApp.service;

import UserApp.dto.UserAndAttractionDTO;
import UserApp.dto.UserGpsDTO;
import UserApp.dto.UserPreferencesDTO;
import UserApp.model.*;
import UserApp.proxy.GpsUtilProxy;
import UserApp.proxy.RewardProxy;
import UserApp.proxy.TripPricerProxy;
import UserApp.testers.InternalUsersSetters;
import UserApp.tracker.Tracker;
import org.javamoney.moneta.Money;
import org.springframework.beans.factory.annotation.Autowired;

import javax.money.Monetary;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.IntStream;

/**
 *
 * &lt;p&gt;UserService is the service class that centralizes all the logic of the Users Application. &lt;/p&gt;
 *
 * &lt;p&gt; UserService makes the link between all the proxies (which are the method signatures of all endpoints of the microservices).&lt;/p&gt;
 * &lt;p&gt;It also makes the link between theses proxies and the tracker (which is the simulation of functioning of the real life application).&lt;/p&gt;
 *
 *
 */
public class UserService {

    @Autowired
    GpsUtilProxy gpsUtilProxy;

    @Autowired
    TripPricerProxy tripPricerProxy;

    @Autowired
    RewardProxy rewardProxy;



    public Tracker tracker;
<span class="fc" id="L46">    public static CopyOnWriteArrayList&lt;User&gt; users = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L47">    public final static ReentrantLock lock = new ReentrantLock();</span>
<span class="fc" id="L48">    public static Boolean testMode = true;</span>



    // ***********************************************************************************************************
    // ************ This part of the code is used in order to simulate the usage by users ************************
    // ***********************************************************************************************************

    /**
     * &lt;p&gt;The constructor of the UserService&lt;/p&gt;
     * &lt;p&gt;If testMode is set to true, it creates a list of Users and launch the tracker for these users.&lt;/p&gt;
     */
<span class="fc" id="L60">    public UserService(){</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">            if(!testMode) {</span>
<span class="nc" id="L62">                initializeAListOfUser();</span>
<span class="nc" id="L63">                tracker = new Tracker(this);</span>
            }
<span class="fc" id="L65">    }</span>


    /**
     * &lt;p&gt;initializeAListOfUser initialize a list of 'users' of type User that would be registered to the app for testing purposes.&lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     */
    private void initializeAListOfUser() {

<span class="nc" id="L74">        IntStream.range(0, InternalUsersSetters.numberOfWantedUsers).forEach( i -&gt; {</span>
<span class="nc" id="L75">            String userName = &quot;internalUser&quot; + i;</span>
<span class="nc" id="L76">            String phone = &quot;000&quot;;</span>
<span class="nc" id="L77">            String email = userName + &quot;@tourguide.com&quot;;</span>
<span class="nc" id="L78">            User user = new User(UUID.randomUUID(), userName, phone, email);</span>
<span class="nc" id="L79">            generateUserLocationHistory(user);</span>

<span class="nc" id="L81">            users.add(user);</span>
<span class="nc" id="L82">        });</span>



<span class="nc" id="L86">    }</span>

    /**
     * generateUserLocationHistory is called by initializeUser in order to create mocks of visited Location of the user.
     *
     * @param user
     *          A user from whom we want to generate a location history for testing purposes.
     */
    private void generateUserLocationHistory(User user) {
<span class="nc" id="L95">        IntStream.range(0, 3).forEach(i -&gt; {</span>
<span class="nc" id="L96">            user.addToVisitedLocations(new VisitedLocation(user.getUserId(),</span>
<span class="nc" id="L97">                    new Location(generateRandomLatitude(), generateRandomLongitude()), getRandomTime()));</span>
<span class="nc" id="L98">        });</span>
<span class="nc" id="L99">    }</span>

    /**
     * &lt;p&gt;generateRandomLongitude generate a random longitude for testing purposes.&lt;/p&gt;
     *
     * @return double
     */
    private double generateRandomLongitude() {
<span class="nc" id="L107">        double leftLimit = -180;</span>
<span class="nc" id="L108">        double rightLimit = 180;</span>
<span class="nc" id="L109">        return leftLimit + new Random().nextDouble() * (rightLimit - leftLimit);</span>
    }

    /**
     * &lt;p&gt;generateRandomLatitude generate a random latitude for testing purposes.&lt;/p&gt;
     *
     * @return double
     */
    private double generateRandomLatitude() {
<span class="nc" id="L118">        double leftLimit = -85.05112878;</span>
<span class="nc" id="L119">        double rightLimit = 85.05112878;</span>
<span class="nc" id="L120">        return leftLimit + new Random().nextDouble() * (rightLimit - leftLimit);</span>
    }

    /**
     * &lt;p&gt;getRandomTime generate a random time for testing purposes.&lt;/p&gt;
     *
     * @return Date
     */
    private Date getRandomTime() {
<span class="nc" id="L129">        LocalDateTime localDateTime = LocalDateTime.now().minusDays(new Random().nextInt(30));</span>
<span class="nc" id="L130">        return Date.from(localDateTime.toInstant(ZoneOffset.UTC));</span>
    }



    // ***********************************************************************************************************
    // ******** This part of the code correspond to the User Domain (managing the users themselves). *************
    // ***********************************************************************************************************

    /**
     * &lt;p&gt; addAUser takes a User as an argument and add it to the list of the application's users.&lt;/p&gt;
     * &lt;p&gt; The method returns null if the users already exist in the list of the application's users.&lt;/p&gt;
     * &lt;p&gt; The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     * @param user
     *            The user that was posted by the client of our application.
     * @return User
     */
    public User addAUser(User user) {

<span class="fc" id="L149">        List&lt;UUID&gt; verification = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L150">        users.forEach(n -&gt; verification.add(n.getUserId()));</span>

<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if(!verification.contains(user.getUserId())) {</span>

<span class="fc" id="L154">            users.add(user);</span>
<span class="fc" id="L155">            int indexOfUser = users.indexOf(user);</span>
<span class="fc" id="L156">            User theUser = users.get(indexOfUser);</span>
<span class="fc" id="L157">            return theUser;</span>

        }else{

<span class="nc" id="L161">            return null;</span>

        }

    }

    /**
     *
     * &lt;p&gt;deleteAUser delete a user from the list of the user's of the application. &lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     * &lt;p&gt;It returns true if the user exists, and false otherwise.&lt;/p&gt;
     *
     * @param userName
     *                The userName posted by the client of our application.
     * @return Boolean
     */
    public Boolean deleteAUser(String userName) {


<span class="fc" id="L180">        User result = getTheUserBasedOnName(userName);</span>

<span class="fc bfc" id="L182" title="All 2 branches covered.">        if(result != null){</span>
<span class="fc" id="L183">            users.remove(result);</span>
<span class="fc" id="L184">            return true;</span>
        }
<span class="fc" id="L186">        return false;</span>
    }

    /**
     *
     * &lt;p&gt;updateUserPreferences takes a string and UserPreferences as arguments. &lt;/p&gt;
     * &lt;p&gt;The method first check if the users exist in the list of the current users of the application&lt;/p&gt;
     * &lt;p&gt;It then changes the preferences of the given users to news preferences (that's where given as argument).&lt;/p&gt;
     * &lt;p&gt;Because of some incompatibility with JavaMoney library and Jackson (and more generally with Java to Json libraries) we use a DTO to register the new preferences.&lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     * @see UserPreferencesDTO
     * @see UserPreferences
     * @param user
     *            The user's 'post' by the client of our application.
     * @param userPref
     *            The new preferences wanted by the client of our application to change the current one's.
     * @return User
     */
    public User updateUserPreferences(String user, UserPreferencesDTO userPref) {

<span class="fc" id="L206">        User userFound = getTheUserBasedOnName(user);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if(userFound != null) {</span>

<span class="fc" id="L209">            int indexOfUser = users.indexOf(userFound);</span>

<span class="fc" id="L211">            User newUser = userFound;</span>
<span class="fc" id="L212">            UserPreferences newPreferences = new UserPreferences();</span>
<span class="fc" id="L213">            newPreferences.setCurrency(Monetary.getCurrency(userPref.getCurrency()));</span>
<span class="fc" id="L214">            newPreferences.setLowerPricePoint(Money.of(userPref.getLowerPricePoint(), newPreferences.getCurrency()));</span>
<span class="fc" id="L215">            newPreferences.setHighPricePoint(Money.of(userPref.getHighPricePoint(), newPreferences.getCurrency()));</span>
<span class="fc" id="L216">            newPreferences.setNumberOfAdults(userPref.getNumberOfAdults());</span>
<span class="fc" id="L217">            newPreferences.setTripDuration(userPref.getTripDuration());</span>
<span class="fc" id="L218">            newPreferences.setTicketQuantity(userPref.getTicketQuantity());</span>
<span class="fc" id="L219">            newPreferences.setNumberOfChildren(userPref.getNumberOfChildren());</span>
<span class="fc" id="L220">            newPreferences.setAttractionProximity(userPref.getAttractionProximity());</span>
<span class="fc" id="L221">            newUser.setUserPreferences(newPreferences);</span>
<span class="fc" id="L222">            users.remove(indexOfUser);</span>
<span class="fc" id="L223">            users.add(indexOfUser, newUser);</span>
<span class="fc" id="L224">            return userFound;</span>
        }

<span class="nc" id="L227">        return null;</span>
    }

    /**
     *
     * &lt;p&gt;getUserPreference request the name of a user as a parameter and return the preferences of this given user.&lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     * @see UserPreferences
     * @param userName
     *              The userName posted by the client of our application.
     * @return
     */
    public UserPreferences getUserPreference(String userName) {

<span class="nc" id="L241">        User result = getTheUserBasedOnName(userName);</span>
<span class="nc" id="L242">        UserPreferences userResult = result.getUserPreferences();</span>
<span class="nc" id="L243">        return userResult;</span>
    }


    /**
     *
     * &lt;p&gt; getUserRewards takes a userName as an argument and returns the list of all rewards for this given user.&lt;/p&gt;
     *
     * &lt;p&gt;This method will return and empty list if the User hasn't received any rewards.&lt;/p&gt;
     * &lt;p&gt;The rewards policy is fixed by the Microservice (RewardsApp in our case).&lt;/p&gt;
     * &lt;p&gt;Therefore, depending on the reward policy set, a user can receive all possible rewards for every attraction or really few.&lt;/p&gt;
     * &lt;p&gt;The return results of this method will depend on this.&lt;/p&gt;
     * &lt;p&gt;It returns null if the user does not exist in the current users of the application.&lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     * @param userName
     *              The userName posted by the client of our application.
     * @return CopyOnWriteArrayList&lt;UserReward&gt;
     */
    public CopyOnWriteArrayList&lt;UserReward&gt; getUserRewards(String userName) {

<span class="nc" id="L263">        User result = getTheUserBasedOnName(userName);</span>
<span class="nc" id="L264">        return result.getUserRewards();</span>

    }

    /**
     * &lt;p&gt;getASpecificUser take a string as an argument, check if the user exists in the current list of all users of the application&lt;/p&gt;
     * &lt;p&gt;The method return the user.&lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     *
     * @see User
     * @param user
     *          The userName that we intend to find in the list of users.
     * @return User
     */
    public User getASpecificUser(String user) {
<span class="fc" id="L279">        User theUser = getTheUserBasedOnName(user);</span>
<span class="fc" id="L280">        return theUser;</span>
    }

    /**
     *
     * &lt;p&gt;getAllUserLocationGivenUser take a string as an argument, check if the provided name relates to a user of the application and
     * returns the list of all visited locations for this given user.
     * &lt;/p&gt;
     * &lt;p&gt;It returns null if the user isn't registered as a user of the application.&lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     * @see VisitedLocation
     * @param userName
     *              The userName posted by the client of our application.
     * @return CopyOnWriteArrayList&lt;VisitedLocation&gt;
     */
    public CopyOnWriteArrayList&lt;VisitedLocation&gt; getAllUserLocationGivenUser(String userName) {

<span class="fc" id="L297">        User result = getTheUserBasedOnName(userName);</span>

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if(result != null){</span>

<span class="fc" id="L301">            return result.getVisitedLocations();</span>
        }

<span class="nc" id="L304">        return null;</span>
    }

    /**
     *
     * &lt;p&gt;getAllLastLocationUsers returns all the visited locations of all current users of the application. &lt;/p&gt;
     * &lt;p&gt;The list of all current registered users is called 'users' in the userService.&lt;/p&gt;
     *
     * @see VisitedLocation
     * @return List&lt;VisitedLocation&gt;
     */
    public List&lt;VisitedLocation&gt; getAllLastLocationUsers() {
<span class="nc" id="L316">        CopyOnWriteArrayList&lt;VisitedLocation&gt; result = new CopyOnWriteArrayList&lt;VisitedLocation&gt;();</span>
<span class="nc" id="L317">        users.forEach(n -&gt; result.add(n.getLastVisitedLocation()));</span>
<span class="nc" id="L318">        return result;</span>
    }


    // *****************************************************************************************************************************************
    // This part correspond off all logic corresponding to the Gps Domain (and therefore the link with the corresponding microservice GpsUtilApp)
    // *****************************************************************************************************************************************

    /**
     *
     * &lt;p&gt;getUserLocation takes a userName as a parameter. It firsts checks if the given name corresponds to a user in the Users list.&lt;/p&gt;
     * &lt;p&gt;it then send solely the required information's (explaining the transformation into a DTO) via the GpsUtil proxy.&lt;/p&gt;
     * &lt;p&gt;It finally returns the last visited location of the user (that has been added by the API).&lt;/p&gt;
     * &lt;p&gt;If the user does not exist in the application current users, it returns null. &lt;/p&gt;
     *
     * @param userName
     *              The user's name from who we want to know the location.
     * @return VisitedLocation
     */
    public VisitedLocation getUserLocation(String userName) {

<span class="fc" id="L339">        User theUser = getTheUserBasedOnName(userName);</span>

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if(theUser != null){</span>
<span class="fc" id="L342">            UserGpsDTO resultToSend = transformUserIntoUserGpsDto(theUser);</span>
<span class="fc" id="L343">            UserGpsDTO updatedResult = gpsUtilProxy.getTheLocation(resultToSend);</span>
<span class="fc" id="L344">            return updatedResult.getVisitedLocations().get(updatedResult.getVisitedLocations().size() - 1);</span>

        }else{

<span class="nc" id="L348">            return null;</span>
        }

    }

    /**
     *
     * &lt;p&gt;getAllAttraction returns all the attractions provided by the provided microservice via the proxy.&lt;/p&gt;
     *
     *
     * @return List&lt;Attraction&gt;
     */
    public List&lt;Attraction&gt; getAllAttraction() {

<span class="fc" id="L362">        List&lt;Attraction&gt; result = gpsUtilProxy.getAllAttraction();</span>
<span class="fc" id="L363">        return result;</span>
    }


    /**
     *
     * &lt;p&gt;getAllFifthClosestAttraction is a requirement from the client.&lt;/p&gt;
     * &lt;p&gt;getAllFifthClosestAttraction takes a userName as a parameter.&lt;/p&gt;
     * &lt;p&gt;The method first check if the given name corresponds to a current user of the application.&lt;/p&gt;
     * &lt;p&gt;It then send solely the required information's (explaining the transformation into a DTO) via the GpsUtil proxy.&lt;/p&gt;
     * &lt;p&gt;It returns a list of five UserNearbyAttraction, that are the closest attractions from the last saved 'VisitedLocation'.&lt;/p&gt;
     * &lt;p&gt;The method then calculates the rewards points related to the attractions via the RewardProxy.&lt;/p&gt;
     *
     *
     * @see RewardProxy
     * @see GpsUtilProxy
     * @param userName
     *              The user's name from whom we want to find the five closest attraction.
     * @return
     */
    public List&lt;UserNearbyAttraction&gt; getAllFiveClosestAttraction(String userName) {

<span class="fc" id="L385">        User theUser = getTheUserBasedOnName(userName);</span>
<span class="fc" id="L386">        System.out.println(&quot;DO WE GET UNTILL HERE MY MAN ? &quot; + theUser.getUserName());</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if(theUser != null){</span>

<span class="fc" id="L389">            UserGpsDTO resultToBeSend = transformUserIntoUserGpsDto(theUser);</span>

<span class="fc" id="L391">            List&lt;UserNearbyAttraction&gt; result = gpsUtilProxy.getFiveClosestAttraction(resultToBeSend);</span>
<span class="fc" id="L392">            System.out.println(&quot;In get5Attraciton, if this thing is null it mean couldn't connect&quot; + result.size());</span>

            //TODO remettre une boucle dans le getRewards.
<span class="fc" id="L395">            result.forEach(n -&gt; n.setRewardsLinkedToTheAttraction(rewardProxy.getTheReward(n.getTheAttraction().attractionId, resultToBeSend.getUserId())));</span>

<span class="fc" id="L397">            return result;</span>

        }

<span class="nc" id="L401">        return null;</span>
    }


    /**
     * &lt;p&gt;getAllLocationOfUsers returns all the last visited locations of all the users' registered in the application.&lt;/p&gt;
     * &lt;p&gt;It first transform the list of all current users into the corresponding DTO in order to send solely the required information's. &lt;/p&gt;
     * &lt;p&gt;It then sends the list to the API in charge of the localization of the users (in our case, GpsUtilApp) via the Proxy.&lt;/p&gt;
     * &lt;p&gt;Once the result is returned, it transforms back the DTO to the corresponding User type and returns a list of the last 'VisitedLocation'&lt;/p&gt;
     *
     *
     * @return List&lt;VisitedLocation&gt;
     */
    public List&lt;VisitedLocation&gt; getAllLocationOfUsers() {

<span class="fc" id="L416">        CopyOnWriteArrayList&lt;UserGpsDTO&gt; toBeSendResult = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L417">        users.forEach( n -&gt; toBeSendResult.add( transformUserIntoUserGpsDto( n )));</span>
<span class="fc" id="L418">        System.out.println(&quot;in getAllLocationUsers I think we are here !! &quot; + users.size());</span>
<span class="fc" id="L419">        List&lt;UserGpsDTO&gt; result = gpsUtilProxy.getAllLocationOfUsers(toBeSendResult);</span>
<span class="fc" id="L420">        System.out.println(&quot; if it's null it means couldn't connect to the service &quot; + result.size() );</span>
<span class="fc" id="L421">        List&lt;User&gt; intermediaryResult = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        for(UserGpsDTO gpsDto : result){</span>
<span class="fc" id="L423">            intermediaryResult.add(saveTheUserDTOAndReturnUser(gpsDto));</span>
<span class="fc" id="L424">        }</span>
<span class="fc" id="L425">        List&lt;VisitedLocation&gt; finalRenderingList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">        for(User u : intermediaryResult){</span>
<span class="fc" id="L428">            finalRenderingList.add(u.getLastVisitedLocation());</span>
<span class="fc" id="L429">        }</span>


<span class="fc" id="L432">        return finalRenderingList;</span>
    }



    // **********************************************************************************************************************************************
    // This part correspond off all logic corresponding to the TripApp Domain (and therefore the link with the corresponding microservice TripApp).
    // **********************************************************************************************************************************************


    //TODO check a quoi sert la clÃ© API et oÃ¹ la mettre !
    /**
     * &lt;p&gt;getAllTheDeals take a userName as parameter and check if the name correspond to a current user of the application&lt;/p&gt;
     * &lt;p&gt;It then send all the preferences of the given user to the API in charge of the pricing of trips (in our case, TripPricerApp).&lt;/p&gt;
     * &lt;p&gt;It returns the list of all providers.&lt;/p&gt;
     *
     * @see Provider
     * @param userName
     *              The user's name from who we want to know the get all the deals.
     * @return List&lt;Provider&gt;
     */
    public List&lt;Provider&gt; getAllTheDeals(String userName) {

<span class="fc" id="L455">        User theUser = getTheUserBasedOnName(userName);</span>
<span class="fc" id="L456">        int totalAmountOfRewards = 0;</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">        for(UserReward s : theUser.getUserRewards()){</span>
<span class="nc" id="L458">            totalAmountOfRewards += s.getRewardPoints();</span>
<span class="nc" id="L459">        }</span>
<span class="fc" id="L460">        return tripPricerProxy.getPrices(&quot;Hey&quot;, theUser.getUserId(), theUser.getUserPreferences().getNumberOfAdults(), theUser.getUserPreferences().getNumberOfChildren(), theUser.getUserPreferences().getTripDuration(), totalAmountOfRewards);</span>
    }


    // **********************************************************************************************************************************************
    // This part correspond off all logic corresponding to the Rewards Domain (and therefore the link with the corresponding microservice RewardApp).
    // **********************************************************************************************************************************************

    /**
     *
     * &lt;p&gt;getAttractionRewardsPoints take as parameters the UUID of an attraction and of a user and returns the rewards points related.&lt;/p&gt;
     *
     * @see RewardProxy
     * @param attraction
     *              The attraction UUID from which we want to generate rewards points.
     * @param user
     *              The UUID of the user that want to generate rewards points.
     *
     * @return
     */
    public int getAttractionRewardsPoints(UUID attraction, UUID user) {

<span class="fc" id="L482">        return rewardProxy.getTheReward(attraction, user);</span>

    }

    /**
     * &lt;p&gt;calculateTheRewardsOfUser take a User as a parameter and a list of attraction.&lt;/p&gt;
     * &lt;p&gt;It transform this information into a DTO in order to send solely the needed information's.&lt;/p&gt;
     * &lt;p&gt;It send the information to the API via proxy in charge of calculating the rewards (in our case, RewardApp).&lt;/p&gt;
     * &lt;p&gt;The proxy returns a DTO with updated UserRewards in correspondence with the rewarding policy set in the API.&lt;/p&gt;
     * &lt;p&gt;It transforms the DTO back into a User and save the new information for the given user and return the given user.&lt;/p&gt;
     *
     * @see UserReward
     * @see UserAndAttractionDTO
     * @param user
     *            The user (from the list of users) from whom we want to calculate the rewards.
     * @param attractions
     *             The list of all attractions that can generate rewards points.
     * @return
     */
    public User calculateTheRewardsOfUser(User user, List&lt;Attraction&gt; attractions){

<span class="fc" id="L503">        UserAndAttractionDTO sendingResult = transformUserIntoUserAndAttractionDTO(user, attractions);</span>
<span class="fc" id="L504">        UserAndAttractionDTO updatedResultTwo = rewardProxy.calculateTheUserReward(sendingResult);</span>
<span class="fc" id="L505">        User result = saveTheUserAndAttractionDTOreturnUser(updatedResultTwo);</span>
<span class="fc" id="L506">        return result;</span>
    }


    /**
     *
     * &lt;p&gt;getAllRewardsPointsOfUsers take a list of attraction as a parameter.&lt;/p&gt;
     * &lt;p&gt;it transform the list of all users of the application into a corresponding list of DTO's in order to solely send required information's.&lt;/p&gt;
     * &lt;p&gt;It send the list of DTO's to the API via the proxy (in our case, the API is RewardApp)&lt;/p&gt;
     * &lt;p&gt;The proxy returns a list of DTO'S with updated UserRewards.&lt;/p&gt;
     * &lt;p&gt;It transform the list of DTO's back into a UserType and save all the information provided back by the proxy.&lt;/p&gt;
     * &lt;p&gt;It returns a Map composed of UserName and of all rewards related to the given user.&lt;/p&gt;
     *
     * @param attractionList
     *             The list of all attraction that can generate rewards points.
     * @return Map&lt;String, List&lt;UserReward&gt;
     */
    public Map&lt;String, List&lt;UserReward&gt;&gt; getAllRewardsPointsOfUsers(List&lt;Attraction&gt; attractionList) {

<span class="fc" id="L525">        List&lt;UserAndAttractionDTO&gt; toBeSentList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L526">        Map&lt;String, List&lt;UserReward&gt;&gt; finalResult = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L528" title="All 2 branches covered.">        for(User u : users){</span>

<span class="fc" id="L530">            toBeSentList.add(transformUserIntoUserAndAttractionDTO(u, attractionList));</span>
<span class="fc" id="L531">        }</span>

<span class="fc" id="L533">        List&lt;UserAndAttractionDTO&gt; result = rewardProxy.calculateTheRewardsForAllTheUsers(toBeSentList);</span>

<span class="fc bfc" id="L535" title="All 2 branches covered.">        for(UserAndAttractionDTO u : result){</span>

<span class="fc" id="L537">            saveTheUserAndAttractionDTOreturnUser(u);</span>
<span class="fc" id="L538">        }</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for(User user : users){</span>

<span class="fc" id="L541">            finalResult.put(user.getUserName(), user.getUserRewards());</span>

<span class="fc" id="L543">        }</span>

<span class="fc" id="L545">        return finalResult;</span>

    }


    // ***********************************************************************************************************
    // ****************                        TRACKER domain                             ************************
    // ***********************************************************************************************************


    /**
     * &lt;p&gt;trackUserLocation centralized all the needed business logic of the application&lt;/p&gt;
     * &lt;p&gt;It assembles all the previous capabilities in order to furnish the service to the Tracker.&lt;/p&gt;
     * &lt;p&gt;It first send the list of all users to the API in charge of the localization (in our case, GpsUtil) via the proxy.&lt;/p&gt;
     * &lt;p&gt;It then send the updated list of users (therefore with new visited location) to the API in charge of the calculus of rewards (in our case, RewardApp) via the proxy.&lt;/p&gt;
     * &lt;p&gt;At each step, it transform the list of current users' of the application into the corresponding DTO (in order to solely send needed information) and save the updated results.&lt;/p&gt;
     * &lt;p&gt;the method returns void because all the necessary logic (adding a new visited location to all users and check if a Rewards is related to it plus saving the updated data) is done in the previous methods.&lt;/p&gt;
     *
     *
     * @see Tracker
     * @see GpsUtilProxy
     * @see RewardProxy
     *
     */
    public void trackUserLocation() {


<span class="nc" id="L572">        CopyOnWriteArrayList&lt;UserGpsDTO&gt; toBeSendData = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="nc" id="L573">        CopyOnWriteArrayList&lt;UserAndAttractionDTO&gt; toBeSendDataAttraction = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="nc" id="L574">        List&lt;Attraction&gt; allAttractions = gpsUtilProxy.getAllAttraction();</span>

<span class="nc bnc" id="L576" title="All 2 branches missed.">        for(User u : users){</span>
<span class="nc" id="L577">            toBeSendData.add(transformUserIntoUserGpsDto(u));</span>
<span class="nc" id="L578">        }</span>
<span class="nc" id="L579">        List&lt;UserGpsDTO&gt; newResult = gpsUtilProxy.getAllLocationOfUsers(toBeSendData);</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">        for(UserGpsDTO gpsDto : newResult){</span>
<span class="nc" id="L582">            saveTheUserDTOAndReturnUser(gpsDto);</span>
<span class="nc" id="L583">        }</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        for(User u : users){</span>
<span class="nc" id="L585">            toBeSendDataAttraction.add(transformUserIntoUserAndAttractionDTO(u, allAttractions));</span>
<span class="nc" id="L586">        }</span>
<span class="nc" id="L587">        List&lt;UserAndAttractionDTO&gt; updatedResultTwo = rewardProxy.calculateTheRewardsForAllTheUsers(toBeSendDataAttraction);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        for(UserAndAttractionDTO attDto : updatedResultTwo){</span>

<span class="nc" id="L590">            saveTheUserAndAttractionDTOreturnUser(attDto);</span>
<span class="nc" id="L591">        }</span>
<span class="nc" id="L592">    }</span>




    // ***********************************************************************************************************
    // ************                            UTIL                                        ************************
    // ***********************************************************************************************************


    /**
     *
     * &lt;p&gt;getTheUserBasedOnName is a utility method. It checks if the provided userName exists in the list of all the current users of the application.&lt;/p&gt;
     * @param userName
     *              The user's name from whom we intend to find the corresponding User in the list of current users.
     * @return User
     */
    public User getTheUserBasedOnName(String userName) {

<span class="fc" id="L611">       Optional&lt;User&gt; result = users.stream().filter(n -&gt; n.getUserName().equals(userName)).findAny();</span>


<span class="fc" id="L614">        return result.orElse(null);</span>
    }

    /**
     * &lt;p&gt;saveTheUserDTOAndReturnUser is a utility method. It takes a DTO as argument, update the corresponding user with the new information's (originated from the proxy) and save the new data's.&lt;/p&gt;
     *
     * @param newResult
     *          The returned DTO from the API which we want to convert back to a User type.
     * @return User
     */
    public User saveTheUserDTOAndReturnUser(UserGpsDTO newResult) {

<span class="fc" id="L626">        User result = getTheUserBasedOnId(newResult.getUserId());</span>
<span class="fc" id="L627">        int indexOfResult = users.indexOf(result);</span>
<span class="fc" id="L628">        result.setVisitedLocations(newResult.getVisitedLocations());</span>
<span class="fc" id="L629">        users.remove(indexOfResult);</span>
<span class="fc" id="L630">        users.add(indexOfResult, result);</span>
<span class="fc" id="L631">        return result;</span>
    }


    /**
     * &lt;p&gt;getTheUserBasedOnId is a utility method. It checks if the provided UUID correspond to a user in the current users' of the application.&lt;/p&gt;
     *
     * @param theId
     *          The UUID from which we intend to find a user corresponding.
     * @return User
     */
    public User getTheUserBasedOnId(UUID theId){

<span class="fc" id="L644">        Optional&lt;User&gt; result = users.stream().filter(n -&gt; n.getUserId().equals(theId)).findAny();</span>

<span class="fc" id="L646">        return result.orElse(null);</span>

    }


    /**
     *
     * &lt;p&gt;transformUserIntoUserGpsDto is a utility method. It takes a User type as argument and transform it into a DTO.&lt;/p&gt;
     * &lt;p&gt;The DTO in question (UserGpsDTO) centralize solely the needed information's of the API for the supply the related services.&lt;/p&gt;
     * &lt;p&gt;It returns a ready to be sent DTO.&lt;/p&gt;
     * @param theUser
     *              the User instance that we want to convert to a DTO to communicate with the API.
     * @return UserGpsDTO
     */
    public UserGpsDTO transformUserIntoUserGpsDto(User theUser) {

<span class="fc" id="L662">        UserGpsDTO result = new UserGpsDTO();</span>
<span class="fc" id="L663">        result.setEmailAddress(theUser.getEmailAddress());</span>
<span class="fc" id="L664">        result.setLatestLocationTimestamp(theUser.getLatestLocationTimestamp());</span>
<span class="fc" id="L665">        result.setPhoneNumber(theUser.getPhoneNumber());</span>
<span class="fc" id="L666">        result.setUserId(theUser.getUserId());</span>
<span class="fc" id="L667">        result.setUserName(theUser.getUserName());</span>
<span class="fc" id="L668">        result.setVisitedLocations(theUser.getVisitedLocations());</span>

<span class="fc" id="L670">        return result;</span>
    }

    /**
     * &lt;p&gt;saveTheUserAndAttractionDTOreturnUser is a utility method. It takes a UserAndAttractionDTO type as an argument (a dedicated type for the API in charge of the rewards).&lt;/p&gt;
     * &lt;p&gt;It finds the corresponding user from the list of all users of the application.&lt;/p&gt;
     * &lt;p&gt;It saves the updated user (with the data from the DTO) into the list of all users of the applications.&lt;/p&gt;
     *
     * @param updatedResultTwo
     *        The result from the DTO that we want to convert back to a User Type.
     * @return User
     */
    public User saveTheUserAndAttractionDTOreturnUser(UserAndAttractionDTO updatedResultTwo) {


<span class="fc" id="L685">        User result = getTheUserBasedOnId(updatedResultTwo.getUserId());</span>
<span class="fc" id="L686">        int indexOfResult = users.indexOf(result);</span>
<span class="fc" id="L687">        result.setUserRewards(updatedResultTwo.getUserRewards());</span>
<span class="fc" id="L688">        users.remove(indexOfResult);</span>
<span class="fc" id="L689">        users.add(indexOfResult, result);</span>
<span class="fc" id="L690">        return result;</span>
    }


    /**
     *
     * &lt;p&gt;transformUserIntoUserAndAttractionDTO is a utility method. It takes a User type as argument and transform it into a DTO.&lt;/p&gt;
     * &lt;p&gt;The DTO in question (UserAndAttractionDTO) centralize solely the needed information's of the API for the supply the related services.&lt;/p&gt;
     * &lt;p&gt;It returns a ready to be sent DTO.&lt;/p&gt;
     * @param newResult
     *              The instance of user that we want to convert into a DTO to send to the API.
     * @param attractions
     *              The list of all existing attractions from which we want to calculate rewards.
     * @return
     */
    public UserAndAttractionDTO transformUserIntoUserAndAttractionDTO(User newResult, List&lt;Attraction&gt; attractions) {

<span class="fc" id="L707">        UserAndAttractionDTO result = new UserAndAttractionDTO();</span>
<span class="fc" id="L708">        result.getVisitedLocations().add((newResult.getLastVisitedLocation()));</span>
<span class="fc" id="L709">        result.setUserRewards(newResult.getUserRewards());</span>
<span class="fc" id="L710">        result.setUserName(newResult.getUserName());</span>
<span class="fc" id="L711">        result.setUserId(newResult.getUserId());</span>
<span class="fc" id="L712">        result.setPhoneNumber(newResult.getPhoneNumber());</span>
<span class="fc" id="L713">        result.setLatestLocationTimestamp(newResult.getLatestLocationTimestamp());</span>
<span class="fc" id="L714">        result.setEmailAddress(newResult.getEmailAddress());</span>
<span class="fc" id="L715">        result.setAttractions(attractions);</span>

<span class="fc" id="L717">        return result;</span>

    }


    // ***********************************************************************************************************
    // ************                Getters and Setters for testing purposes               ************************
    // ***********************************************************************************************************

    public GpsUtilProxy getGpsUtilProxy() {
<span class="nc" id="L727">        return gpsUtilProxy;</span>
    }

    public void setGpsUtilProxy(GpsUtilProxy gpsUtilProxy) {
<span class="fc" id="L731">        this.gpsUtilProxy = gpsUtilProxy;</span>
<span class="fc" id="L732">    }</span>

    public TripPricerProxy getTripPricerProxy() {
<span class="nc" id="L735">        return tripPricerProxy;</span>
    }

    public void setTripPricerProxy(TripPricerProxy tripPricerProxy) {
<span class="fc" id="L739">        this.tripPricerProxy = tripPricerProxy;</span>
<span class="fc" id="L740">    }</span>

    public RewardProxy getRewardProxy() {
<span class="nc" id="L743">        return rewardProxy;</span>
    }

    public void setRewardProxy(RewardProxy rewardProxy) {
<span class="fc" id="L747">        this.rewardProxy = rewardProxy;</span>
<span class="fc" id="L748">    }</span>




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>